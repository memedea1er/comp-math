"""
Основные переменные:
w: размерность слова (word size) в битах. В алгоритме Вихря Мерсенна это 32 бита.
n: степень рекуррентного отношения. В алгоритме Вихря Мерсенна используется 624.
m: индекс, при котором происходит "скручивание" (twist). В алгоритме Вихря Мерсенна это 397.
r: количество битов, используемых в нижней маске. В алгоритме Вихря Мерсенна это 31.
a: константа для преобразования. В алгоритме Вихря Мерсенна это 0x9908B0DF.
u: количество битов для сдвига вправо в процессе темпериования. В алгоритме Вихря Мерсенна это 11.
d: маска для применения после сдвига вправо в процессе темпериования. В алгоритме Вихря Мерсенна это 0xFFFFFFFF.
s: количество битов для сдвига влево в процессе темпериования. В алгоритме Вихря Мерсенна это 7.
b: маска для применения после сдвига влево и побитового ИЛИ в процессе темпериования. В алгоритме Вихря Мерсенна это 0x9D2C5680.
t: количество битов для сдвига влево в процессе темпериования. В алгоритме Вихря Мерсенна это 15.
c: маска для применения после сдвига влево и побитового ИЛИ в процессе темпериования. В алгоритме Вихря Мерсенна это 0xEFC60000.
l: количество битов для сдвига вправо в процессе темпериования. В алгоритме Вихря Мерсенна это 18.
f: множитель для инициализации состояния. В алгоритме Вихря Мерсенна это 1812433253.

Дополнительные переменные и структуры:
MT: массив для хранения состояния генератора. Его длина равна n (624).
index: текущий индекс в массиве состояния MT. Инициализируется значением n + 1, чтобы указать, что состояние требует скручивания (twist) при первом использовании.
lower_mask: маска для получения нижних r битов. Это (1 << r) - 1.
upper_mask: маска для получения верхних w - r битов. Это побитовое отрицание lower_mask, ограниченное размером w битов.

Функции:
twist(): функция, которая выполняет скручивание массива MT, чтобы обновить его состояние.
extract_number(): функция, которая извлекает псевдослучайное число из текущего состояния MT и применяет к нему темпериование.

Пример использования:
seed: начальное значение для инициализации генератора. В примере это 5489.
mt: функция, возвращаемая генератором, которая генерирует следующее псевдослучайное число при каждом вызове.
"""

import time

def mersenne_twister(seed):
    # Параметры алгоритма Mersenne Twister
    w, n, m, r = 32, 624, 397, 31
    a = 0x9908B0DF
    u, d = 11, 0xFFFFFFFF
    s, b = 7, 0x9D2C5680
    t, c = 15, 0xEFC60000
    l = 18
    f = 1812433253

    # Инициализация массива состояний
    MT = [0] * n
    index = n + 1
    lower_mask = (1 << r) - 1
    upper_mask = (~lower_mask) & (2 ** w - 1)

    # Инициализация генератора чисел по заданному seed
    MT[0] = seed # Первый элемент массива MT[0] инициализируется заданным начальным значением seed.
    for i in range(1, n): # Остальные элементы массива MT инициализируются с помощью рекуррентного выражения
        temp = f * (MT[i - 1] ^ (MT[i - 1] >> (w - 2))) + i # операция XOR предыдущего значения с сдвинутой копией предыдущего значения
        MT[i] = temp & (2 ** w - 1) # применение операции побитового И к temp для установки w наименее значимых битов

    # Функция, которая возвращает следующее случайное число
    def twist(): # Выполняет обновление состояния генератора путем "скручивания" массива MT.
        nonlocal index
        for i in range(n):
            x = (MT[i] & upper_mask) + (MT[(i + 1) % n] & lower_mask) # Вычисление нового значения x путем объединения двух частей: верхней и нижней
            xA = x >> 1 # xA получает половину значения x, сдвигая его на один бит вправо
            if x % 2 != 0:
                xA ^= a # Для каждого элемента массива MT вычисляется новое значение на основе комбинации верхних битов текущего элемента и нижних битов следующего элемента.
            MT[i] = MT[(i + m) % n] ^ xA # Новое значение комбинируется с элементом, сдвинутым на m позиций, и константой a для обеспечения неравномерности.
        index = 0

    # Извлечение следующего числа из генератора
    def extract_number():
        nonlocal index
        if index >= n: # Если индекс больше или равен n, выполняется скручивание (twist()), чтобы обновить состояние массива MT.
            if index > n:
                twist()
            index = 0
        y = MT[index] # Извлекается значение y из текущего элемента массива MT.
        # К значению y последовательно применяются темпериующие преобразования для улучшения распределения случайных чисел
        y ^= (y >> u) & d # Побитовый сдвиг вправо и побитовое И
        y ^= (y << s) & b # Побитовый сдвиг влево и побитовое ИЛИ
        y ^= (y << t) & c # Побитовый сдвиг влево и побитовое ИЛИ
        y ^= y >> l # Побитовый сдвиг вправо

        index += 1
        return y & (2 ** w - 1) # Операция & (побитовое И) применяется к значению y и маске (2 ** w - 1), где (2 ** w - 1) устанавливает все биты, младше w, в 1, а остальные в 0

    return extract_number


# Пример использования
if __name__ == "__main__":
    seed = 5489  # Пример сид
    seed = int(time.time())  # Сид по текущему времени
    print(f"Seed used: {seed}")
    mt = mersenne_twister(seed)
    for i in range(10):
        print(mt())
